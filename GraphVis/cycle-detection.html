<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Cycle Detection</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8f9fa;
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 20px;
    }

    h2 {
      color: #555;
      margin-top: 30px;
      margin-bottom: 10px;
    }

    p {
      line-height: 1.6;
      margin-bottom: 15px;
    }

    ul {
      margin-bottom: 20px;
    }

    .code-block {
      background-color: #f7f7f7;
      border-left: 4px solid #007bff;
      padding: 10px 15px;
      font-family: 'Courier New', Courier, monospace;
      overflow-x: auto;
      font-size: 0.95em;
    }

    footer {
      text-align: center;
      padding: 15px;
      background-color: #f1f1f1;
      margin-top: 40px;
    }

    a {
      text-decoration: none;
      color: #007bff;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Cycle Detection</h1>
    <p>
      Detecting cycles in graphs is a fundamental problem in computer science with different approaches depending on
      whether the graph is directed or undirected. Here, I will explain the optimal methods for each type of graph.
    </p>

    <h2>Cycle Detection in Undirected Graphs</h2>
    <p>
      The most efficient algorithm for cycle detection in an undirected graph is the <strong>Union-Find</strong>
      algorithm (also known as <strong>Disjoint Set Union</strong>, or DSU).
    </p>
    <p><strong>Why Union-Find?</strong></p>
    <ul>
      <li>
        Union-Find efficiently groups nodes into connected components and detects cycles by determining whether adding
        an edge would connect two nodes already in the same component.
      </li>
      <li>
        With optimizations like <em>path compression</em> and <em>union by rank</em>, it operates in
        near-constant time per operation.
      </li>
    </ul>
    <p><strong>Time Complexity:</strong> <span style="font-family: 'Courier New', monospace;">O(E × α(V))</span>, where
      <span style="font-family: 'Courier New', monospace;">E</span> is the number of edges,
      <span style="font-family: 'Courier New', monospace;">V</span> is the number of vertices, and
      <span style="font-family: 'Courier New', monospace;">α</span> is the inverse Ackermann function (very close to
      constant).
    </p>
    <h2>Cycle Detection in Directed Graphs</h2>
    <p>
      The most efficient algorithm for cycle detection in directed graphs is <strong>Topological Sort</strong>, with
      <strong>Kahn's Algorithm</strong> being a popular implementation.
    </p>
    <p><strong>Why Topological Sort?</strong></p>
    <ul>
      <li>
        Topological Sort attempts to order the nodes in a directed graph linearly. If it is not possible to process all
        nodes (i.e., some nodes remain with incoming edges), the graph contains a cycle.
      </li>
      <li>
        This approach leverages the properties of Directed Acyclic Graphs (DAGs) and is both simple and efficient.
      </li>
    </ul>
    <p><strong>Time Complexity:</strong> <span style="font-family: 'Courier New', monospace;">O(V + E)</span></p>

    <h2>Alternative Approaches</h2>
    <h3>Depth-First Search (DFS)</h3>
    <p>
      DFS is a versatile method for cycle detection but is less efficient than Union-Find or Kahn's Algorithm in
      specific contexts.
    </p>
    <ul>
      <li>
        In undirected graphs, DFS can detect cycles by tracking visited nodes and ensuring we do not mistake the parent
        node as part of a cycle.
      </li>
      <li>
        In directed graphs, DFS detects cycles by identifying back edges (edges pointing to an ancestor node in the
        recursion stack).
      </li>
    </ul>
    <p><strong>Time Complexity:</strong> <span style="font-family: 'Courier New', monospace;">O(V + E)</span>, but
      constant factors such as recurision and auxillary date structures make it less practical for large graphs
      compared to specialized algorithms.</p>

    <h2>Summary</h2>
    <ul>
      <li><strong>Undirected Graphs:</strong> Use <strong>Union-Find</strong> for optimal cycle detection.</li>
      <li><strong>Directed Graphs:</strong> Use <strong>Kahn's Algorithm</strong> (Topological Sort) for efficient cycle
        detection.</li>
      <li><strong>DFS:</strong> A versatile but less optimal method compared to the specialized algorithms above.</li>
    </ul>
  </div>

</body>

</html>
